'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.lsrMatch = lsrMatch;
exports.lsrMatchSync = lsrMatchSync;
exports.readdirMatch = readdirMatch;
exports.readdirMatchSync = readdirMatchSync;

var sander = require('sander');

// Synchronous helper function - given an array of filenames, run the minimatch
// patterns.
function _filterPattern(filenames, patterns) {

	var minimatch = require('minimatch'),
	    matching = new Set();

	if (!Array.isArray(patterns)) {
		patterns = [patterns];
	}

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = patterns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var pattern = _step.value;
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = filenames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var filename = _step2.value;

					if (minimatch(filename, pattern)) {
						matching.add(filename);
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2['return']) {
						_iterator2['return']();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator['return']) {
				_iterator['return']();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return matching;
}

// @function lsr(...paths, patterns): Promise
// Returns a promise of an Set of filenames: the result of doing a recursive
// file listing on the paths (like the 'lsr' function of sander.js), then
// filtered by the minimatch patterns.
// The `patterns` argument is a minimatch expression (which can be a string or
// an array of minimatch expressions).
// As the result is a Set, a filename will appear at most once, and filenames
// will be ordered, the ones matching the first pattern first.

function lsrMatch() {
	// Apparently babelJS chokes on `(...paths, patterns)`
	var patterns = arguments[arguments.length - 1];
	var paths = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
	return sander.lsr.apply(this, paths).then(function (allFiles) {
		return _filterPattern(allFiles, patterns);
	});
}

;

// @function lsrMatchSync(...paths, patterns): Promise
// like `lsrMatch`, but using the 'lsrSync' function of sander.js instead.

function lsrMatchSync() {
	// Apparently babelJS chokes on `(...paths, patterns)`
	var patterns = arguments[arguments.length - 1];
	var paths = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
	return sander.lsrSync.apply(this, paths).then(function (allFiles) {
		return _filterPattern(allFiles, patterns);
	});
}

;

// @function readdirMatch(...paths, patterns): Promise
// like `lsrMatch`, but using the 'readdir' function of sander.js instead.

function readdirMatch() {
	// Apparently babelJS chokes on `(...paths, patterns)`
	var patterns = arguments[arguments.length - 1];
	var paths = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
	return sander.readdir.apply(this, paths).then(function (allFiles) {
		return _filterPattern(allFiles, patterns);
	});
}

;

// @function readdirMatchSync(...paths, patterns): Promise
// like `lsrMatch`, but using the 'readdirSync' function of sander.js instead.

function readdirMatchSync() {
	// Apparently babelJS chokes on `(...paths, patterns)`
	var patterns = arguments[arguments.length - 1];
	var paths = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
	return sander.readdirSync.apply(this, paths).then(function (allFiles) {
		return _filterPattern(allFiles, patterns);
	});
}

;
//# sourceMappingURL=sandermatch.js.map
